<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workflow Task Management</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    <style>
        .task-row {
            margin-bottom: 20px;
        }
        .form-select {
            width: 200px;
        }
        .form-select:disabled {
            background-color: #e9ecef;
            pointer-events: none;
            color: #6c757d;
        }
    </style>
</head>
<body>
    <div class="container mt-5">
        <h1 class="text-center">Workflow Task Management</h1>
        <div id="workflowContainer" class="mt-4"></div>
    </div>

    <script>
    document.addEventListener("DOMContentLoaded", () => {
        const displayData = JSON.parse(localStorage.getItem("displayData")) || [];
        const insertsData = JSON.parse(localStorage.getItem("insertsData")) || {};
        const workflowContainer = document.getElementById("workflowContainer");
    
        const mainWorkflow = displayData.find(wf => wf.workflowId === "mainWorkflow");
        if (!mainWorkflow || !mainWorkflow.tasks.length) return console.error("No tasks found in Main Workflow.");
    
        const renderedTaskIds = new Set();
    
        const sortedTasks = mainWorkflow.tasks.sort((a, b) =>
            a.milestone - b.milestone || a.taskNumber - b.taskNumber
        );
    
        renderMilestoneTasks(getLowestMilestone(sortedTasks));
    
        function getLowestMilestone(tasks) {
            return Math.min(...tasks.map(task => parseInt(task.milestone)));
        }
    
        function renderMilestoneTasks(milestone) {
            const milestoneTasks = sortedTasks.filter(task => task.milestone == milestone);
            milestoneTasks.forEach((task, index) => createTaskRow(task, index === 0));
        }
    
        function createTaskRow(task, enableDropdown) {
            if (renderedTaskIds.has(task.id)) return; // Prevent duplicate rendering
    
            renderedTaskIds.add(task.id);
    
            const taskRow = document.createElement("div");
            taskRow.className = "task-row";
            taskRow.dataset.id = task.id;
    
            const taskLabel = document.createElement("span");
            taskLabel.textContent = `${task.name} (Task ${task.taskNumber})`;
            taskLabel.className = "me-3";
    
            const dropdown = document.createElement("select");
            dropdown.className = "form-select";
            dropdown.disabled = !enableDropdown;
    
            dropdown.innerHTML = `<option value="">Select a result</option>`;
            task.results.forEach(result => {
                const option = document.createElement("option");
                option.value = result.result;
                option.textContent = result.result;
                dropdown.appendChild(option);
            });
    
            dropdown.addEventListener("change", () => handleDropdownChange(task, dropdown));
    
            taskRow.appendChild(taskLabel);
            taskRow.appendChild(dropdown);
            workflowContainer.appendChild(taskRow);
        }
    
        function handleDropdownChange(task, dropdown) {
            const selectedResult = dropdown.value;
            if (!selectedResult) return;
        
            console.log(`Task selected: ${task.name}, Result: ${selectedResult}`);
            dropdown.disabled = true; // Ensure dropdown is permanently disabled
        
            const taskKey = `mainWorkflow-${task.id}-${selectedResult}`;
            console.log(`Generated task key: ${taskKey}`);
        
            if (insertsData[taskKey]) {
                console.log(`Handling insert for key: ${taskKey}`);
                const insertValue = insertsData[taskKey];
                handleInsert(task, insertValue);
            } else {
                console.log(`No insert found for key: ${taskKey}. Proceeding to enable next task.`);
                enableNextTaskInMilestone(task);
            }
        }
        
        function handleInsert(task, insertValue) {
            if (insertValue.includes("-")) {
                // Singular task insertion
                const parts = insertValue.split("-");
                const taskId = parts.slice(-2).join("-"); // Extract task ID (last two parts)
                const insertedTask = displayData
                    .flatMap(wf => wf.tasks)
                    .find(t => t.id === taskId);
        
                if (insertedTask) {
                    console.log(`Inserting singular task: ${insertedTask.name}`);
                    insertTaskBelow(task, insertedTask);
                } else {
                    console.warn(`Task with ID ${taskId} not found in displayData.`);
                }
            } else {
                // Subworkflow insertion
                const subWorkflow = displayData.find(wf => wf.title === insertValue);
                if (subWorkflow) {
                    console.log(`Rendering Sub Workflow: ${subWorkflow.title}`);
                    renderMilestoneTasks(getLowestMilestone(subWorkflow.tasks));
                } else {
                    console.warn(`Sub Workflow "${insertValue}" not found.`);
                }
            }
        }
        
        function insertTaskBelow(currentTask, newTask) {
            // Get the last inserted instance of the current task
            const taskRows = document.querySelectorAll(`[data-id^="${currentTask.id}"]`);
            const taskRow = taskRows[taskRows.length - 1]; // Use the last instance
        
            if (!taskRow) {
                console.warn(`Task row for ${currentTask.name} not found`);
                return;
            }
        
            // Always create a new row for the task
            const newTaskRow = document.createElement("div");
            newTaskRow.className = "task-row";
            newTaskRow.dataset.id = `${newTask.id}-${Date.now()}`; // Generate unique ID for each insertion
        
            const taskLabel = document.createElement("span");
            taskLabel.textContent = `${newTask.name} (Inserted Task)`;
            taskLabel.className = "me-3";
        
            const dropdown = document.createElement("select");
            dropdown.className = "form-select";
        
            dropdown.innerHTML = `<option value="">Select a result</option>`;
            newTask.results.forEach(result => {
                const option = document.createElement("option");
                option.value = result.result;
                option.textContent = result.result;
                dropdown.appendChild(option);
            });
        
            dropdown.addEventListener("change", () => handleDropdownChange(newTask, dropdown));
        
            newTaskRow.appendChild(taskLabel);
            newTaskRow.appendChild(dropdown);
        
            // Insert the new task row directly below the last instance of the current task
            taskRow.after(newTaskRow);
        
            console.log(`Inserted task "${newTask.name}" below "${currentTask.name}" with options:`, newTask.results.map(r => r.result));
        }

        
        function enableNextTaskInMilestone(currentTask) {
            console.log(`Enabling next task in milestone for: ${currentTask.name}`);
            const currentTaskRow = document.querySelector(`[data-id="${currentTask.id}"]`);
            if (!currentTaskRow) {
                console.warn(`Current task row not found for: ${currentTask.name}`);
                return;
            }
        
            const nextTaskRow = currentTaskRow.nextElementSibling;
            if (nextTaskRow && nextTaskRow.querySelector("select")) {
                const nextDropdown = nextTaskRow.querySelector("select");
                if (!nextDropdown.disabled) {
                    console.log(`Next task already enabled: ${nextTaskRow.dataset.id}`);
                    return;
                }
        
                nextDropdown.disabled = false;
                console.log(`Enabled dropdown for next task: ${nextTaskRow.dataset.id}`);
            } else {
                console.log("No more tasks in the current milestone. Checking for the next milestone...");
                const nextMilestone = parseInt(currentTask.milestone) + 1;
                const nextMilestoneTasks = sortedTasks.filter(task => task.milestone == nextMilestone);
                if (nextMilestoneTasks.length > 0) {
                    renderMilestoneTasks(nextMilestone);
                } else {
                    console.log("All tasks completed.");
                }
            }
        }

    });
    </script>

</body>
</html>
