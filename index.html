<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cityworks Workflow Configurator</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
</head>
<body>
    <div class="container mt-5">
        <h1 class="text-center">Cityworks Workflow Configurator</h1>
        <p class="text-center">Upload your Draw.io (.drawio) file to configure your workflow.</p>

        <!-- File Upload Section -->
        <div class="mb-4">
            <label for="drawioUpload" class="form-label">Upload Draw.io File:</label>
            <input type="file" id="drawioUpload" class="form-control" accept=".drawio">
        </div>

        <!-- Task and Results Section -->
        <div id="taskContainer" class="d-none">
            <h3>Tasks and Results</h3>
            <div id="tasks" class="mt-3"></div>
        </div>

        <!-- Next Button -->
        <div class="text-center mt-4">
            <button id="nextButton" class="btn btn-primary d-none">Next</button>
        </div>
    </div>

    <script>
        document.getElementById('drawioUpload').addEventListener('change', handleFileUpload);

        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                const fileContent = e.target.result;
                processDrawioFile(fileContent); // Extract tasks and lines
            };
            reader.readAsText(file);
        }

        function extractStatuses(xmlDoc) {
            const statuses = [];

            xmlDoc.querySelectorAll('mxCell').forEach(cell => {
                const value = cell.getAttribute('value') || '';
                const style = cell.getAttribute('style') || '';

                // Identify statuses dynamically based on common style attributes
                if (style.includes('edgeLabel') && style.includes('align=left') && style.includes('verticalAlign=bottom')) {
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = value;
                    const cleanValue = tempDiv.textContent.trim();

                    if (cleanValue && !statuses.includes(cleanValue)) {
                        statuses.push(cleanValue);
                    }
                }
            });

            return statuses;
        }

        function processDrawioFile(fileContent) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(fileContent, 'text/xml');

            const statuses = extractStatuses(xmlDoc);
            const tasks = [];
            const connections = [];

            // Extract connections (lines) from the diagram
            xmlDoc.querySelectorAll('mxCell[edge="1"]').forEach(cell => {
                const source = cell.getAttribute('source');
                const lineText = cell.getAttribute('value') || 'No text associated with this line';

                if (source) {
                    connections.push({ source, text: lineText.trim() });
                }
            });

            // Extract tasks and associate their connections
            xmlDoc.querySelectorAll('mxCell[style*="rounded=1"]').forEach(cell => {
                const rawValue = cell.getAttribute('value') || 'Unnamed Task';
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = rawValue;
                const taskName = tempDiv.textContent.trim(); // Extract plain text

                const taskId = cell.getAttribute('id');
                const taskConnections = connections
                    .filter(connection => connection.source === taskId)
                    .map(connection => connection.text);

                tasks.push({ id: taskId, name: taskName, connections: taskConnections });
            });

            renderTasks(tasks, statuses);
        }

        function renderTasks(tasks, statuses) {
            const taskContainer = document.getElementById('taskContainer');
            const tasksDiv = document.getElementById('tasks');
            const nextButton = document.getElementById('nextButton');
            tasksDiv.innerHTML = '';

            const taskData = []; // Collect data for saving

            tasks.forEach(task => {
                const taskRow = document.createElement('div');
                taskRow.className = 'task-row mb-3';

                const taskLabel = document.createElement('label');
                taskLabel.className = 'form-label';
                taskLabel.innerText = `Task: ${task.name} (ID: ${task.id})`;
                taskRow.appendChild(taskLabel);

                const taskResults = [];

                if (task.connections.length > 0) {
                    const connectionList = document.createElement('ul');
                    task.connections.forEach(connection => {
                        const listItem = document.createElement('li');
                        if (connection !== 'No text associated with this line') {
                            const dropdown = document.createElement('select');
                            dropdown.className = 'form-select mt-1';

                            // Populate dropdown with dynamic statuses
                            dropdown.innerHTML = `<option value="">Select Status</option>`;
                            statuses.forEach(status => {
                                dropdown.innerHTML += `<option value="${status}">${status}</option>`;
                            });

                            const connectionText = document.createElement('span');
                            connectionText.innerText = connection;
                            connectionText.className = 'me-2';

                            listItem.appendChild(connectionText);
                            listItem.appendChild(dropdown);

                            taskResults.push({ result: connection, status: dropdown });
                        } else {
                            listItem.innerText = connection;
                        }
                        connectionList.appendChild(listItem);
                    });
                    taskRow.appendChild(connectionList);
                } else {
                    const noConnectionMessage = document.createElement('p');
                    noConnectionMessage.innerText = 'No connections associated with this task.';
                    noConnectionMessage.className = 'text-muted';
                    taskRow.appendChild(noConnectionMessage);
                }

                tasksDiv.appendChild(taskRow);
                taskData.push({ id: task.id, name: task.name, results: taskResults });
            });

            nextButton.classList.remove('d-none');

            // Save data to localStorage when Next is clicked
            nextButton.addEventListener('click', () => {
                const savedData = taskData.map(task => ({
                    id: task.id,
                    name: task.name,
                    results: task.results.map(result => ({
                        result: result.result,
                        status: result.status.value,
                    })),
                }));

                localStorage.setItem('workflowData', JSON.stringify(savedData));
                window.location.href = 'workflow.html'; // Redirect to the next page
            });

            taskContainer.classList.remove('d-none');
        }
    </script>
</body>
</html>
